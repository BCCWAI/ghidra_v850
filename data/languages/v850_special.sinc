
# (15) Special instructions



# NOP
define pcodeop __nop;
:nop is op0015=0x0000 {
	__nop();
}

# SYNCE
define pcodeop __synchronize;
:synce is op0015=0x001D {
	__synchronize();
}
# SYNCM
:syncm is op0015=0x001E {
	__synchronize();
}
# SYNCP
:syncp is op0015=0x001F {
	__synchronize();
}

# RIE
:rie is op0015=0x0040 unimpl # reserved instruction for future expansion

# SWITCH reg1
:switch R0004 is op0515=0x002 & R0004 {
	local lbl:4 = inst_next + (R0004 << 1);
	local addr:4 = inst_next + (sext(*:2 lbl) << 1);
	PC = addr;
	goto [addr];
}

# FETRAP vector4
:fetrap op1114 is op0010=0x040 & op1515=0 & op1114 & op1115!=0 {
	TODO();
}

# CALLT imm6
:callt op0005 is op0615=0x080 & op0005 {
	CTPC = inst_next;
	CTPSW = PSW;
	local lbl:4 = CTBP + (op0005 << 1);
	local addr:4 = CTBP + zext(*:2 lbl);
	PC = addr;
	call [addr];
}

# RIE
:rie is op0410=0x7F; op1631=0 unimpl # reserved instruction for future expansion

# LDSR reg2, regID
:ldsr R0004, SR1115 is op0510=0x3F & SR1115 & R0004; op1631=0x20 {
	SR1115 = R0004;
}
# STSR regID, reg2
:stsr SR0004, r1115 is op0510=0x3F & r1115 & SR0004; op1631=0x40 {
	r1115 = SR0004;
}


macro _ternary(res, cond, avar, bvar)
{ res = (avar * zext(cond != 0)) + (bvar * zext(cond == 0)); }

# CAXI [reg1], reg2, reg3
:caxi [R0004], R1115, R2731 is op0510=0x3F & R0004 & R1115; op1626=0xEE & R2731 {
	local token = *:4 R0004;
	local result = R1115 - token;
	*:4 R0004 = token * zext(result != 0) +
				R2731 * zext(result == 0);
	R2731 = token;
	flags_sub(R1115, token);
}

# TRAP imm5
:trap op0004 is op0515=0x3F & op0004; op1631=0x0100 {
	TODO();
}

# HALT
define pcodeop __halt;
:halt is op0515=0x3F; op1631=0x0120 {
	__halt();
}
# RETI
:reti is op0515=0x3F; op1631=0x0140 {
	TODO();
}
# CTRET
:ctret is op0515=0x3F; op1631=0x0144 {
	PC = CTPC;
	PSW = CTPSW;
	return [PC];
}
# EIRET
:eiret is op0515=0x3F; op1631=0x0148 {
	PC = EIPC;
	PSW = EIPSW;
	return [PC];
}
# FERET
:feret is op0515=0x3F; op1631=0x014A {
	PC = FEPC;
	PSW = FEPSW;
	return [PC];
}

# DI
define pcodeop __disable_irq;
:di is op0015=0x07E0; op1631=0x0160 {
	$(PSW_ID) = 1;
	__disable_irq();
}
# EI
define pcodeop __enable_irq;
:ei is op0015=0x87E0; op1631=0x0160 {
	$(PSW_ID) = 0;
	__enable_irq();
}

# SYSCALL vector8
:syscall vector8 is op0515=0x6BF & op0004; op3031=0 & op2729 & op1626=0x160 
[ vector8 = (op2729 << 5) | op0004; ] {
	TODO();
}

